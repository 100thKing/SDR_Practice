# 2. Дискретизация сигналов. Вычисление ДПФ
Аналоговый сигнал x(t)=Acos(ωt) при дискретизации с интервалом времени T_s преобразуется в последовательность дискретных значений (чисел) x(n)=Acos(ωnT_s)=Acos(Ωn)
Часть 1.
1. Задайте сигнал с частотой f, Гц, выберите частоту дискретизации fs отсч/сек. Получите набор отсчетов сигнала размером 64, 128, 256, изобразите выборку отсчетов командой plt.stem
2. Определите значение аналоговой частоты сигнала, которая соответствует нормированной частоте Ω=0.1π рад, Ω=0.3π при fs первого раздела
3. При помощи функции fft модуля numpy вычислите ДПФ сигнала из раздела 1 для трех наборов отсчетов. Изобразите модуль спектра ДПФ с указанием частотной оси в Гц.

Часть 2. 
Основы цифровой фильтрации
Сформируй те сигнал, состоящий из суммы двух гармонических колебаний (косинусов) разных частот. Выберите частоту дискретизации для данного сигнала. Изобразите спектр ДПФ полученных отсчетов.
Рассчитайте отсчеты цифрового фильтра ФНЧ с частотой среза для подавления сигнала с большей частотой. Импульсная характеристика ФНЧ вычисляется по выражению h(n)=  (sin⁡(Ω_cn))/πn, Ω_c – нормированная частота среза. Примените полученную импульсную характеристику фильтра к входному сигналу.
Изобразите спектр ДПФ сигнала после фильтрации

# Выполнение
## Начальный сигнал
<details>
    <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%98%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB.jpeg">
</details>

## Дискретизация для трёх наборов отсчётов размерами 64, 128 и 256 
<details>
    <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB.png">
</details>

## Аналоговые частоты, которые соотвествтуют нормированным частотам Ω = 0.1π и Ω = 0.3π
  ```python
  Q = 0.1 * np.pi
  x_Q_01 = (Q *fs) / (2*np.pi) ## = 50.0
  
  Q = 0.3 * np.pi
  x_Q_03 = (Q *fs) / (2*np.pi) ## = 150.0
  ```

##  Cпектры для данных сигналов с количеством отсчётов n = 64, 128, 256
<details>
    <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D1%80%D0%B0.jpeg">
</details>

## Сигнал, состоящий из двух гармонических колебаний
```python
x1 = np.cos(50*np.pi*fc1*t)
x2 = np.cos(9*np.pi*fc2*t)

signal_2cos = x1+x2
```
<details>
    <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5_%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%B0.jpeg" name="first">
   <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%2C%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D1%89%D0%B8%D0%B9%20%D0%B8%D0%B7%20%D0%B4%D0%B2%D1%83%D1%85%20%D0%B3%D0%B0%D1%80%D0%BC%D0%BE%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%20%D0%BA%D0%BE%D0%BB%D0%B5%D0%B1%D0%B0%D0%BD%D0%B8%D0%B9.jpeg">
</details>

## Фильтр
```python
fc = 5/fs 
N = 50
n = np.arange(0, N)
h = np.sinc(2 * fc * (n - (N - 1) / 2))
```
<details>
  <img src="https://github.com/100thKing/SDR_Practice/blob/main/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5/source/%D0%A1%D1%83%D0%BC%D0%BC%D0%B0_cos.jpeg">
</details>

